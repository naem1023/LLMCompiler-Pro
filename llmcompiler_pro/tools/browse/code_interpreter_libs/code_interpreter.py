import json
import traceback
from typing import TypedDict

import pika
from langchain_core.messages.ai import AIMessage
from langchain_core.messages.base import BaseMessage
from langchain_core.messages.human import HumanMessage
from logzero import logger

from main.auto_agent.prompt_render.jinja2_render import Jinja2Render

from .code_executor import CodeExecutorLocal
from .code_generator import CodeGenerator


class CodeInterpreterResult(TypedDict):
    # Generated by Code Executor
    execution_result: str | None
    images: list[str] | None

    # Generated by Code Generator
    thought: str
    code: str | None
    answer: str | None


class CodeInterpreter:
    def __init__(self, model_name: str, callbacks: list = None, iteration: int = 3):
        self.executor = (
            CodeExecutorLocal()
        )  # Local jupyter session is the default executor.
        self.generator = CodeGenerator(model_name)
        self.iteration = iteration
        self.prompt_render = Jinja2Render("demo/prompt")
        self.routing_key = "code_interpreter"

    @staticmethod
    def is_python_code(response: list) -> bool:
        """Check if the response is python code.

        - If the "python" type is in the response, return True.
        - Other scenario, return False.
        """
        if isinstance(response, list):
            return any([r.get("type") == "python" for r in response])
        else:
            return False

    def compose_chat_history(
        self,
        chat_history: list[BaseMessage],
        current_goal: str,
        codes: list[CodeInterpreterResult],
    ) -> list[BaseMessage]:
        """Compose the chat history to use in iterative code interpreter flow.

        Append the user, assistant messages to represent the code interpreter flow.
        - user message: request the code generation or providing the answer
        - assistant message: provide the code execution result or the code snippet, or the answer
        """
        user_prompt = self.prompt_render.render(
            "auto_agent",
            "code_interpreter_user_prompt.jinja2",
            current_goal=current_goal,
        )
        if len(codes) != 0:
            execution_result = codes[-1].get("execution_result")
            code = codes[-1].get("code")
            images = codes[-1].get("images", None)
            answer = codes[-1].get("answer", None)
            thought = codes[-1].get("thought", None)
        else:
            execution_result = None
            code = None
            images = None
            answer = None
            thought = None

        assistant_prompt = self.prompt_render.render(
            "auto_agent",
            "code_interpreter_assistant_prompt.jinja2",
            execution_result=execution_result,
            code=code,
            images=images,
            answer=answer,
            thought=thought,
        )
        chat_history = [
            *chat_history,
            HumanMessage(content=user_prompt),
            AIMessage(content=assistant_prompt),
        ]
        return chat_history

    def export_code_execution_result(
        self, result: CodeInterpreterResult, current_goal: str
    ):
        """Export the code execution result to Message Queue

        Publish code, execution results and images to the message queue.
        """
        result["current_goal_from_plan"] = current_goal
        data = json.dumps(result, indent=2)

        connection = pika.BlockingConnection(
            pika.ConnectionParameters(host="localhost")
        )
        channel = connection.channel()
        channel.queue_declare(queue=self.routing_key)
        channel.basic_publish(
            exchange="", routing_key=self.routing_key, body=bytes(data, "utf-8")
        )
        logger.info(
            f"CodeInterpreter send {data} to the task queue to show on the client."
        )

    async def run(
        self,
        user_input: str,
        chat_history: list[dict],
        plan: str,
        current_goal: str,
    ) -> list[CodeInterpreterResult]:
        """Generate the action of code interpreter.

        Iterate these steps:
        1. Generate the code snippet or the freeform text.
        2. Determine the iterative generation by Code generation results.
            2.a If Code generator decides to terminate the code generation, it returns the string object.
                End of the loop.
            2.b Otherwise code generator returns a list of dict object.
                Continue the loop.

        TODO: Save generated code snippet and its execution result.
        """
        current_iteration = 0

        _chat_history = []
        for c in chat_history:
            if c.get("type") == "human":
                _chat_history.append(HumanMessage(content=c.get("content")))
            elif c.get("type") == "ai":
                _chat_history.append(AIMessage(content=c.get("content")))
            else:
                raise ValueError(f"{c} can't convert to langchain messages.")
        chat_history = _chat_history

        codes: list[CodeInterpreterResult] = []

        logger.debug(f"Code Interpreter run with {user_input}")
        try:
            while current_iteration < self.iteration:
                # Not containing the system prompt.
                current_iteration += 1
                chat_history = self.compose_chat_history(
                    chat_history, current_goal, codes
                )

                # Generate the code or the answer.
                code_generation_response: list | str = await self.generator.generate(
                    user_input, chat_history, plan, current_goal
                )

                if isinstance(code_generation_response, list):
                    # TODO: Assume that the response has only one thought. Add exceptions.
                    _thought = [
                        r
                        for r in code_generation_response
                        if r.get("type") == "thought"
                    ]
                    thought = _thought[0].get("content")

                    # Check the response has python code or not
                    if self.is_python_code(code_generation_response):
                        # Ensure the response has python code execution result.
                        # TODO: Assume that the response has only one python code. Add exceptions.
                        _code = [
                            r
                            for r in code_generation_response
                            if r.get("type") == "python"
                        ]
                        code = _code[0].get("content")

                        code_execution_result = await self.executor.execute(code)
                        codes.append(
                            CodeInterpreterResult(
                                execution_result=code_execution_result.get("result"),
                                images=code_execution_result.get("images", None),
                                code=code,
                                answer=None,
                                thought=thought,
                            )
                        )

                        # Publish the code execution result to the message queue.
                        self.export_code_execution_result(codes[-1], current_goal)
                    else:
                        # Code generator decide to terminate the code generation.
                        _answer = [
                            r
                            for r in code_generation_response
                            if r.get("type") == "text"
                        ]
                        answer = _answer[0].get("content")
                        codes.append(
                            CodeInterpreterResult(
                                execution_result=None,
                                images=None,
                                code=None,
                                answer=answer,
                                thought=thought,
                            )
                        )
                        break
                else:
                    # Code Generator fail to generate valid json format to response.
                    codes.append(
                        CodeInterpreterResult(
                            execution_result=None,
                            images=None,
                            code=None,
                            answer=None,
                            thought=code_generation_response,
                        )
                    )
                    break

            # Don't close the jupyter session. It can be used multiple times.
            # Outer manager should close all the jupyter session.
            # await self.executor.close()

            # TODO: The last output may not always be the answer. Fix the final response.
            return codes
        except Exception as e:
            logger.error(
                f"Error is raised on code interpreter, {traceback.format_exc()}"
            )
            raise e

    async def close(self):
        await self.executor.close()
        self.connection.close()
